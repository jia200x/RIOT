From c49e1784dc9327657fb552a0bee466ea93e2603b Mon Sep 17 00:00:00 2001
From: Francisco <femolina@uc.cl>
Date: Fri, 11 Nov 2016 15:33:52 -0300
Subject: [PATCH] fixed library problem

---
 src/mac/LoRaMacCrypto.c | 74 ++++++++++++++++++++++++-------------------------
 1 file changed, 36 insertions(+), 38 deletions(-)

diff --git a/src/mac/LoRaMacCrypto.c b/src/mac/LoRaMacCrypto.c
index 0a50a64..28d6d5e 100644
--- a/src/mac/LoRaMacCrypto.c
+++ b/src/mac/LoRaMacCrypto.c
@@ -19,10 +19,10 @@ Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jä
 */
 #include <stdlib.h>
 #include <stdint.h>
-#include "loramac/utilities.h"
+#include "loramac/utilities.h"
 
-#include "loramac/aes.h"
-#include "loramac/cmac.h"
+#include "crypto/ciphers.h"
+#include "hashes/cmac.h"
 
 #include "LoRaMacCrypto.h"
 
@@ -32,6 +32,12 @@ Maintainer: Miguel Luis ( Semtech ), Gregory Cristian ( Semtech ) and Daniel Jä
 #define LORAMAC_MIC_BLOCK_B0_SIZE                   16
 
 /*!
+ * Key size
+ */
+#define KEYSIZE                                     16
+
+
+/*!
  * MIC field computation initial data
  */
 static uint8_t MicBlockB0[] = { 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
@@ -43,7 +49,7 @@ static uint8_t MicBlockB0[] = { 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  *
  * \remark Only the 4 first bytes are used
  */
-static uint8_t Mic[16];
+static uint8_t digest[16];
 
 /*!
  * Encryption aBlock and sBlock
@@ -56,14 +62,16 @@ static uint8_t sBlock[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           };
 
 /*!
- * AES computation context variable
+ * CMAC computation context variable
  */
-static aes_context AesContext;
+
+static cmac_context CmacContext;
 
 /*!
- * CMAC computation context variable
+ * Aes computation context variable
  */
-static AES_CMAC_CTX AesCmacCtx[1];
+
+static cipher_t    AesContext;;
 
 /*!
  * \brief Computes the LoRaMAC frame MIC field  
@@ -92,17 +100,12 @@ void LoRaMacComputeMic( const uint8_t *buffer, uint16_t size, const uint8_t *key
 
     MicBlockB0[15] = size & 0xFF;
 
-    AES_CMAC_Init( AesCmacCtx );
-
-    AES_CMAC_SetKey( AesCmacCtx, key );
+    cmac_init(&CmacContext, key, KEYSIZE);
+    cmac_update(&CmacContext, MicBlockB0, LORAMAC_MIC_BLOCK_B0_SIZE );
+    cmac_update(&CmacContext, buffer, size);
+    cmac_final(&CmacContext, digest);
 
-    AES_CMAC_Update( AesCmacCtx, MicBlockB0, LORAMAC_MIC_BLOCK_B0_SIZE );
-    
-    AES_CMAC_Update( AesCmacCtx, buffer, size & 0xFF );
-    
-    AES_CMAC_Final( Mic, AesCmacCtx );
-    
-    *mic = ( uint32_t )( ( uint32_t )Mic[3] << 24 | ( uint32_t )Mic[2] << 16 | ( uint32_t )Mic[1] << 8 | ( uint32_t )Mic[0] );
+    *mic = ( uint32_t )( ( uint32_t )digest[3] << 24 | ( uint32_t )digest[2] << 16 | ( uint32_t )digest[1] << 8 | ( uint32_t )digest[0] );
 }
 
 void LoRaMacPayloadEncrypt( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t address, uint8_t dir, uint32_t sequenceCounter, uint8_t *encBuffer )
@@ -111,8 +114,7 @@ void LoRaMacPayloadEncrypt( const uint8_t *buffer, uint16_t size, const uint8_t
     uint8_t bufferIndex = 0;
     uint16_t ctr = 1;
 
-    memset1( AesContext.ksch, '\0', 240 );
-    aes_set_key( key, 16, &AesContext );
+    cipher_init(&AesContext, CIPHER_AES_128, key, KEYSIZE);
 
     aBlock[5] = dir;
 
@@ -130,7 +132,7 @@ void LoRaMacPayloadEncrypt( const uint8_t *buffer, uint16_t size, const uint8_t
     {
         aBlock[15] = ( ( ctr ) & 0xFF );
         ctr++;
-        aes_encrypt( aBlock, sBlock, &AesContext );
+        cipher_encrypt(&AesContext, aBlock, sBlock);
         for( i = 0; i < 16; i++ )
         {
             encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
@@ -142,7 +144,7 @@ void LoRaMacPayloadEncrypt( const uint8_t *buffer, uint16_t size, const uint8_t
     if( size > 0 )
     {
         aBlock[15] = ( ( ctr ) & 0xFF );
-        aes_encrypt( aBlock, sBlock, &AesContext );
+        cipher_encrypt(&AesContext, aBlock, sBlock);
         for( i = 0; i < size; i++ )
         {
             encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
@@ -157,26 +159,22 @@ void LoRaMacPayloadDecrypt( const uint8_t *buffer, uint16_t size, const uint8_t
 
 void LoRaMacJoinComputeMic( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint32_t *mic )
 {
-    AES_CMAC_Init( AesCmacCtx );
-
-    AES_CMAC_SetKey( AesCmacCtx, key );
+    cmac_init(&CmacContext, key, KEYSIZE);
+    cmac_update(&CmacContext, buffer, size);
+    cmac_final(&CmacContext, digest);
 
-    AES_CMAC_Update( AesCmacCtx, buffer, size & 0xFF );
-
-    AES_CMAC_Final( Mic, AesCmacCtx );
-
-    *mic = ( uint32_t )( ( uint32_t )Mic[3] << 24 | ( uint32_t )Mic[2] << 16 | ( uint32_t )Mic[1] << 8 | ( uint32_t )Mic[0] );
+    *mic = ( uint32_t )( ( uint32_t )digest[3] << 24 | ( uint32_t )digest[2] << 16 | ( uint32_t )digest[1] << 8 | ( uint32_t )digest[0] );
 }
 
 void LoRaMacJoinDecrypt( const uint8_t *buffer, uint16_t size, const uint8_t *key, uint8_t *decBuffer )
 {
-    memset1( AesContext.ksch, '\0', 240 );
-    aes_set_key( key, 16, &AesContext );
-    aes_encrypt( buffer, decBuffer, &AesContext );
+    cipher_init(&AesContext, CIPHER_AES_128, key, KEYSIZE);
+    cipher_encrypt(&AesContext, buffer, decBuffer);
+
     // Check if optional CFList is included
     if( size >= 16 )
     {
-        aes_encrypt( buffer + 16, decBuffer + 16, &AesContext );
+        cipher_encrypt(&AesContext, buffer + 16, decBuffer + 16);
     }
 }
 
@@ -185,18 +183,18 @@ void LoRaMacJoinComputeSKeys( const uint8_t *key, const uint8_t *appNonce, uint1
     uint8_t nonce[16];
     uint8_t *pDevNonce = ( uint8_t * )&devNonce;
     
-    memset1( AesContext.ksch, '\0', 240 );
-    aes_set_key( key, 16, &AesContext );
+    cipher_init(&AesContext, CIPHER_AES_128, key, KEYSIZE);
 
     memset1( nonce, 0, sizeof( nonce ) );
     nonce[0] = 0x01;
     memcpy1( nonce + 1, appNonce, 6 );
     memcpy1( nonce + 7, pDevNonce, 2 );
-    aes_encrypt( nonce, nwkSKey, &AesContext );
+    cipher_encrypt(&AesContext, nonce, nwkSKey);
 
     memset1( nonce, 0, sizeof( nonce ) );
     nonce[0] = 0x02;
     memcpy1( nonce + 1, appNonce, 6 );
     memcpy1( nonce + 7, pDevNonce, 2 );
-    aes_encrypt( nonce, appSKey, &AesContext );
+    cipher_encrypt(&AesContext, nonce, appSKey);
+
 }
-- 
2.7.4

